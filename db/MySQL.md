# MySQL

## 인덱스 

인덱스는 결국 지정한 컬럼들을 기준으로 메모리 영역에 일종의 목차를 생성하는 

### 주요 특징 
- 인덱스 탐색은 Root -> Branch -> Leaf -> 디스크 저장소 순으로 진행된다. 
- 인덱스의 두번째 컬럼은 첫 번째 컬럼에 의존해서 정렬된다.


### 인덱스 키 값의 크기 

인덱스 역시 페이지 단위로 관리되며 페이지는 16KB 로 크기가 고정된다.

~~~
만약 인덱스의 크기가 16 Byte 경우 

자식노드(Branch, Leaf)의 주소 12 Byte 정도라고 가정하면 

16*1024 / (16+12) = 585 하나의 페이지에 585개 저장가능하다.

인덱스의 크기가 커짐에 따라서 페이지 성능 이슈가 생긴다.

~~~

### 인덱스 컬럼 기준 

> 카디널리티(Cardinality)란 해당 컬럼의 중복된 수치를 나타냅니다.
> 예를 들어 성별, 학년 등은 카디널리티가 낮다고 얘기합니다.
> 반대로 주민등록번호, 계좌번호 등은 카디널리티가 높다고 얘기합니다.

1. 만약 여러 컬럼으로 인덱스를 잡는다면? :  카디널리티가가 높은순에서 낮은순으로 구성하는게 좋다.
2. 여러 컬럼으로 인덱스시 조건 누락 : 첫번째 인덱스 컬럼이 조회 쿼리에 없으면 인덱스를 타지 않는다는 점을 기억하시면 됩니다.


### 인덱스 조회시 주의 사항

- between, like, <, > 등 범위 조건은 해당 컬럼은 인덱스를 타지만, 그 뒤 인덱스 컬럼들은 인덱스가 사용되지 않습니다.

즉, group_no, from_date, is_bonus으로 인덱스가 잡혀있는데 조회 쿼리를 where group_no=XX and is_bonus=YY and from_date > ZZ등으로 잡으면 is_bonus는 인덱스가 사용되지 않습니다. 

- 반대로 =, in 은 다음 컬럼도 인덱스를 사용합니다.
	- in은 결국 =를 여러번 실행시킨 것이기 때문입니다.
	- 단, in은 인자값으로 상수가 포함되면 문제 없지만, 서브쿼리를 넣게되면 성능상 이슈가 발생합니다.
	- in의 인자로 서브쿼리가 들어가면 서브쿼리의 외부가 먼저 실행되고, in 은 체크조건으로 실행되기 때문입니다.

- AND연산자는 각 조건들이 읽어와야할 ROW수를 줄이는 역할을 하지만, or 연산자는 비교해야할 ROW가 더 늘어나기 때문에 풀 테이블 스캔이 발생할 확률이 높습니다.

- 인덱스로 사용된 컬럼값 그대로 사용해야만 인덱스가 사용됩니다. 

- null 값의 경우 is null 조건으로 인덱스 레인지 스캔 가능




### Reference

- https://jojoldu.tistory.com/243
